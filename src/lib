import * as XLSX from 'xlsx';

// 定义单词类型
export interface Word {
  id: string;
  japanese: string;
  chinese: string;
  pronunciation?: string;
  example?: string;
}

/**
 * 解析Excel文件并提取单词数据
 * @param file - 上传的Excel文件
 * @returns 解析后的单词数组Promise
 */
export const parseExcelFile = async (file: File): Promise<Word[]> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      try {
        const data = new Uint8Array(e.target?.result as ArrayBuffer);
        const workbook = XLSX.read(data, { type: 'array' });
        
        // 获取第一个工作表
        if (workbook.SheetNames.length === 0) {
          reject(new Error('Excel文件中没有找到工作表，请确保文件包含数据'));
          return;
        }
        
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        
        // 将工作表转换为JSON
        const jsonData: any[] = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
        
        // 过滤空行
        const nonEmptyRows = jsonData.filter(row => 
          row.some((cell: any) => cell !== null && cell !== undefined && cell !== '')
        );
        
        if (nonEmptyRows.length < 2) {
          reject(new Error('Excel文件中没有足够的数据，请确保包含标题行和至少一个单词数据行'));
          return;
        }
        
        // 获取标题行并标准化（更宽松的匹配）
        const headers = nonEmptyRows[0].map((header: any) => 
          header ? String(header).trim().toLowerCase() : ''
        );
        
        // 查找必要的列索引（增加更多关键词提高识别率）
        const japaneseIndex = headers.findIndex(h => 
          h.includes('日语') || h.includes('日文') || h.includes('japanese') || 
          h.includes('jp') || h.includes('nihongo')
        );
        
        const chineseIndex = headers.findIndex(h => 
          h.includes('中文') || h.includes('汉语') || h.includes('chinese') || 
          h.includes('cn') || h.includes('zhongwen')
        );
        
        const pronunciationIndex = headers.findIndex(h => 
          h.includes('发音') || h.includes('罗马音') || h.includes('pronunciation') ||
          h.includes('音') || h.includes('roma') || h.includes('reading')
        );
        
        const exampleIndex = headers.findIndex(h => 
          h.includes('例句') || h.includes('例子') || h.includes('example') ||
          h.includes('句') || h.includes('sentence')
        );
        
        // 验证必要的列是否存在，并提供具体错误信息
        if (japaneseIndex === -1 && chineseIndex === -1) {
          reject(new Error('未找到日语和中文列，请确保标题行包含"日语"或"中文"相关列'));
          return;
        } else if (japaneseIndex === -1) {
          reject(new Error('未找到日语列，请确保标题行包含"日语"、"日文"或"japanese"等关键词'));
          return;
        } else if (chineseIndex === -1) {
          reject(new Error('未找到中文列，请确保标题行包含"中文"、"汉语"或"chinese"等关键词'));
          return;
        }
        
        // 解析单词数据
        const words: Word[] = [];
        
        // 从数据行开始解析（跳过标题行）
        for (let i = 1; i < nonEmptyRows.length; i++) {
          const row = nonEmptyRows[i];
          
          // 获取单元格数据并处理可能的空值
          const japaneseCell = row[japaneseIndex];
          const chineseCell = row[chineseIndex];
          
          // 跳过日语和中文都为空的行
          if (!japaneseCell && !chineseCell) continue;
          
          // 验证单元格数据
          if (!japaneseCell) {
            reject(new Error(`第${i+1}行缺少日语单词数据，请检查文件内容`));
            return;
          }
          
          if (!chineseCell) {
            reject(new Error(`第${i+1}行缺少中文翻译数据，请检查文件内容`));
            return;
          }
          
          const word: Word = {
            id: `word-${Date.now()}-${i}`,
            japanese: String(japaneseCell).trim(),
            chinese: String(chineseCell).trim(),
          };
          
          // 添加可选字段
          if (pronunciationIndex !== -1 && row[pronunciationIndex]) {
            word.pronunciation = String(row[pronunciationIndex]).trim();
          }
          
          if (exampleIndex !== -1 && row[exampleIndex]) {
            word.example = String(row[exampleIndex]).trim();
          }
          
          words.push(word);
        }
        
        if (words.length === 0) {
          reject(new Error('未找到有效的单词数据，请检查文件格式和内容'));
          return;
        }
        
        resolve(words);
      } catch (error) {
        reject(new Error(`解析Excel文件时出错: ${error instanceof Error ? error.message : String(error)}`));
      }
    };
    
    reader.onerror = () => {
      reject(new Error('读取文件时出错，请检查文件是否损坏或格式是否正确'));
    };
    
    reader.readAsArrayBuffer(file);
  });
};

/**
 * 随机打乱数组顺序
 * @param array - 要打乱的数组
 * @returns 打乱后的新数组
 */
export const shuffleArray = <T,>(array: T[]): T[] => {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
};
/**
 * 五十音图数据 - 包含平假名、片假名和罗马音
 */
export const fiftySoundsData = {
  rows: [
    {
      rowName: 'あ行',
      characters: [
        { hiragana: 'あ', katakana: 'ア', romaji: 'a' },
        { hiragana: 'い', katakana: 'イ', romaji: 'i' },
        { hiragana: 'う', katakana: 'ウ', romaji: 'u' },
        { hiragana: 'え', katakana: 'エ', romaji: 'e' },
        { hiragana: 'お', katakana: 'オ', romaji: 'o' },
      ]
    },
    {
      rowName: 'か行',
      characters: [
        { hiragana: 'か', katakana: 'カ', romaji: 'ka' },
        { hiragana: 'き', katakana: 'キ', romaji: 'ki' },
        { hiragana: 'く', katakana: 'ク', romaji: 'ku' },
        { hiragana: 'け', katakana: 'ケ', romaji: 'ke' },
        { hiragana: 'こ', katakana: 'コ', romaji: 'ko' },
      ]
    },
    {
      rowName: 'さ行',
      characters: [
        { hiragana: 'さ', katakana: 'サ', romaji: 'sa' },
        { hiragana: 'し', katakana: 'シ', romaji: 'shi' },
        { hiragana: 'す', katakana: 'ス', romaji: 'su' },
        { hiragana: 'せ', katakana: 'セ', romaji: 'se' },
        { hiragana: 'そ', katakana: 'ソ', romaji: 'so' },
      ]
    },
    {
      rowName: 'た行',
      characters: [
        { hiragana: 'た', katakana: 'タ', romaji: 'ta' },
        { hiragana: 'ち', katakana: 'チ', romaji: 'chi' },
        { hiragana: 'つ', katakana: 'ツ', romaji: 'tsu' },
        { hiragana: 'て', katakana: 'テ', romaji: 'te' },
        { hiragana: 'と', katakana: 'ト', romaji: 'to' },
      ]
    },
    {
      rowName: 'な行',
      characters: [
        { hiragana: 'な', katakana: 'ナ', romaji: 'na' },
        { hiragana: 'に', katakana: 'ニ', romaji: 'ni' },
        { hiragana: 'ぬ', katakana: 'ヌ', romaji: 'nu' },
        { hiragana: 'ね', katakana: 'ネ', romaji: 'ne' },
        { hiragana: 'の', katakana: 'ノ', romaji: 'no' },
      ]
    },
    {
      rowName: 'は行',
      characters: [
        { hiragana: 'は', katakana: 'ハ', romaji: 'ha' },
        { hiragana: 'ひ', katakana: 'ヒ', romaji: 'hi' },
        { hiragana: 'ふ', katakana: 'フ', romaji: 'fu' },
        { hiragana: 'へ', katakana: 'ヘ', romaji: 'he' },
        { hiragana: 'ほ', katakana: 'ホ', romaji: 'ho' },
      ]
    },
    {
      rowName: 'ま行',
      characters: [
        { hiragana: 'ま', katakana: 'マ', romaji: 'ma' },
        { hiragana: 'み', katakana: 'ミ', romaji: 'mi' },
        { hiragana: 'む', katakana: 'ム', romaji: 'mu' },
        { hiragana: 'め', katakana: 'メ', romaji: 'me' },
        { hiragana: 'も', katakana: 'モ', romaji: 'mo' },
      ]
    },
    {
      rowName: 'や行',
      characters: [
        { hiragana: 'や', katakana: 'ヤ', romaji: 'ya' },
        { hiragana: 'ゆ', katakana: 'ユ', romaji: 'yu' },
        { hiragana: 'よ', katakana: 'ヨ', romaji: 'yo' },
      ]
    },
    {
      rowName: 'ら行',
      characters: [
        { hiragana: 'ら', katakana: 'ラ', romaji: 'ra' },
        { hiragana: 'り', katakana: 'リ', romaji: 'ri' },
        { hiragana: 'る', katakana: 'ル', romaji: 'ru' },
        { hiragana: 'れ', katakana: 'レ', romaji: 're' },
        { hiragana: 'ろ', katakana: 'ロ', romaji: 'ro' },
      ]
    },
    {
      rowName: 'わ行',
      characters: [
        { hiragana: 'わ', katakana: 'ワ', romaji: 'wa' },
        { hiragana: 'を', katakana: 'ヲ', romaji: 'wo' },
        { hiragana: 'ん', katakana: 'ン', romaji: 'n' },
      ]
    }
  ]
};

// 导出所有行名称，用于选择练习行
export const rowNames = fiftySoundsData.rows.map(row => row.rowName);

// 练习类型定义
export type PracticeType = 'romaji-to-hiragana' | 'romaji-to-katakana' | 'hiragana-to-romaji' | 'katakana-to-romaji';

export const practiceTypes = [
  { value: 'romaji-to-hiragana', label: '罗马音 → 平假名' },
  { value: 'romaji-to-katakana', label: '罗马音 → 片假名' },
  { value: 'hiragana-to-romaji', label: '平假名 → 罗马音' },
  { value: 'katakana-to-romaji', label: '片假名 → 罗马音' },
];
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
